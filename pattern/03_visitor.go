package pattern

import "fmt"

/*
	Реализовать паттерн «посетитель».
	Описывает операцию, выполняемую с каждым объектом из некотрой структуры.
	Патерн посетитель позволяет определить новую операцию, не изменяя класса этих объектов.
*/

/*
	Применим когда:
	- в структуре присутствуют объекты многих классов с различными интерфейчасми и вы хотите
	выполнить над ними операции, зависящие от конкретных классов.
	- над объектами, входящими в состав структуры, должны выполняться разнообразные, не
	связанные между собой операции и вы не хотите "засорять" классы такими операциями.
	- классы, определяющие структуру объекта, изменяются редко, но новые операции над этой
	структурой добовляются часто.
*/

/*
	Плюсы:
	- упрощение добавлений новых операций.
	- объединение родственных операций и отсечение тех, которые не имеют к ним отношения.
	- накопление состояния.
*/

/*
	Минусы:
	- трудности с добавлением подкласов классов.
	- не способность работать со структурами состоящими из объектов разных типов.
	- нарушение инкапсуляции.
*/

type SCar struct{}

func (c *SCar) info() string {
	return "Базовый набор машины"
}

func (c *SCar) accept(visitor func(c *SCar)) {
	visitor(c)
}

type Tesla struct {
	SCar
}

func (c *Tesla) info() string {
	return "Электрокар"
}

type BMW struct {
	SCar
}

func (c *BMW) info() string {
	return "Красивая машинка"
}

type Audi struct {
	SCar
}

func (c *Audi) info() string {
	return "Хз что.."
}

type ICanShow interface {
	info() string
}

func exportVisitor(car *SCar) {
	if ok := ICanShow(car); ok != nil {
		fmt.Println(car.info())
	}
}

func UseVisitor() {
	q := Tesla{}
	q.accept(exportVisitor)
	w := BMW{}
	w.accept(exportVisitor)
	e := Audi{}
	e.accept(exportVisitor)
}
